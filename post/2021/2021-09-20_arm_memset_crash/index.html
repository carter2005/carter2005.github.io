<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>arm memset crash - carter&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="carter2005" /><meta name="description" content="设备信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 root@wang-1604:~# lspci -d 1e36: -vv 01:00.0 Processing accelerators: Shanghai Enflame Technology Co." /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.3 with theme even" />


<link rel="canonical" href="https://carter2005.github.io/post/2021/2021-09-20_arm_memset_crash/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css" rel="stylesheet">
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="arm memset crash" />
<meta property="og:description" content="设备信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 root@wang-1604:~# lspci -d 1e36: -vv 01:00.0 Processing accelerators: Shanghai Enflame Technology Co." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://carter2005.github.io/post/2021/2021-09-20_arm_memset_crash/" />
<meta property="article:published_time" content="2021-09-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-09-20T00:00:00+00:00" />
<meta itemprop="name" content="arm memset crash">
<meta itemprop="description" content="设备信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 root@wang-1604:~# lspci -d 1e36: -vv 01:00.0 Processing accelerators: Shanghai Enflame Technology Co.">
<meta itemprop="datePublished" content="2021-09-20T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2021-09-20T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="6787">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="arm memset crash"/>
<meta name="twitter:description" content="设备信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 root@wang-1604:~# lspci -d 1e36: -vv 01:00.0 Processing accelerators: Shanghai Enflame Technology Co."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">carter&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">carter&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">arm memset crash</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-09-20 </span>
        
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设备信息">设备信息</a></li>
    <li><a href="#normal-memory和device-memory">normal memory和device memory</a></li>
    <li><a href="#io-memory">io memory</a></li>
    <li><a href="#write-combine">write combine</a></li>
    <li><a href="#arm-memset问题">ARM memset问题</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="设备信息">设备信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">root@wang-1604:~# lspci -d 1e36: -vv
01:00.0 Processing accelerators: Shanghai Enflame Technology Co. Ltd T10 <span class="o">[</span>CloudBlazer<span class="o">]</span> <span class="o">(</span>rev 01<span class="o">)</span>
        Subsystem: Shanghai Enflame Technology Co. Ltd T10 <span class="o">[</span>CloudBlazer<span class="o">]</span>
        Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- <span class="nv">DEVSEL</span><span class="o">=</span>fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
        Latency: 0, Cache Line Size: <span class="m">64</span> bytes
        Interrupt: pin A routed to IRQ 16
        Region 0: Memory at a2000000 <span class="o">(</span>32-bit, non-prefetchable<span class="o">)</span> <span class="o">[</span><span class="nv">size</span><span class="o">=</span>16K<span class="o">]</span>
        Region 1: Memory at a1000000 <span class="o">(</span>32-bit, non-prefetchable<span class="o">)</span> <span class="o">[</span><span class="nv">size</span><span class="o">=</span>16M<span class="o">]</span>
        Region 2: Memory at <span class="m">4000000000</span> <span class="o">(</span>64-bit, prefetchable<span class="o">)</span> <span class="o">[</span><span class="nv">size</span><span class="o">=</span>16G<span class="o">]</span>
        Capabilities: <span class="o">[</span>40<span class="o">]</span> Power Management version 3
                Flags: PMEClk- DSI- D1- D2- <span class="nv">AuxCurrent</span><span class="o">=</span>0mA PME<span class="o">(</span>D0+,D1-,D2-,D3hot+,D3cold-<span class="o">)</span>
                Status: D0 NoSoftRst+ PME-Enable- <span class="nv">DSel</span><span class="o">=</span><span class="m">0</span> <span class="nv">DScale</span><span class="o">=</span><span class="m">0</span> PME-
        Capabilities: <span class="o">[</span>50<span class="o">]</span> MSI: Enable- <span class="nv">Count</span><span class="o">=</span>1/1 Maskable+ 64bit+
                Address: <span class="m">0000000000000000</span>  Data: 0000
                Masking: <span class="m">00000000</span>  Pending: 00000000
        Capabilities: <span class="o">[</span>70<span class="o">]</span> Express <span class="o">(</span>v2<span class="o">)</span> Endpoint, MSI 00
                DevCap: MaxPayload <span class="m">512</span> bytes, PhantFunc 0, Latency L0s unlimited, L1 unlimited
                        ExtTag+ AttnBtn- AttnInd- PwrInd- RBE+ FLReset-
                DevCtl: Report errors: Correctable- Non-Fatal- Fatal- Unsupported-
                        RlxdOrd+ ExtTag+ PhantFunc- AuxPwr- NoSnoop+
                        MaxPayload <span class="m">256</span> bytes, MaxReadReq <span class="m">512</span> bytes
                DevSta: CorrErr- UncorrErr- FatalErr- UnsuppReq- AuxPwr- TransPend-
                LnkCap: Port <span class="c1">#0, Speed 16GT/s, Width x16, ASPM L0s L1, Exit Latency L0s &lt;4us, L1 &lt;64us</span>
                        ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+
                LnkCtl: ASPM Disabled<span class="p">;</span> RCB <span class="m">64</span> bytes Disabled- CommClk+
                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                LnkSta: Speed 8GT/s, Width x16, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
                DevCap2: Completion Timeout: Range ABCD, TimeoutDis+, LTR-, OBFF Not Supported
                DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis-, LTR-, OBFF Disabled
                LnkCtl2: Target Link Speed: 16GT/s, EnterCompliance- SpeedDis-
                         Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-
                         Compliance De-emphasis: -6dB
                LnkSta2: Current De-emphasis Level: -3.5dB, EqualizationComplete+, EqualizationPhase1+
                         EqualizationPhase2+, EqualizationPhase3+, LinkEqualizationRequest-
        Capabilities: <span class="o">[</span>b0<span class="o">]</span> MSI-X: Enable+ <span class="nv">Count</span><span class="o">=</span><span class="m">8</span> Masked-
                Vector table: <span class="nv">BAR</span><span class="o">=</span><span class="m">0</span> <span class="nv">offset</span><span class="o">=</span>00000000
                PBA: <span class="nv">BAR</span><span class="o">=</span><span class="m">0</span> <span class="nv">offset</span><span class="o">=</span>00001000
        Capabilities: <span class="o">[</span><span class="m">100</span> v2<span class="o">]</span> Advanced Error Reporting
                UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-
                CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- NonFatalErr-
                CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- NonFatalErr+
                AERCap: First Error Pointer: 00, GenCap+ CGenEn- ChkCap+ ChkEn-
        Capabilities: <span class="o">[</span><span class="m">148</span> v1<span class="o">]</span> <span class="c1">#19</span>
        Capabilities: <span class="o">[</span><span class="m">178</span> v1<span class="o">]</span> <span class="c1">#26</span>
        Capabilities: <span class="o">[</span>1a8 v1<span class="o">]</span> <span class="c1">#27</span>
        Capabilities: <span class="o">[</span>1f0 v1<span class="o">]</span> <span class="c1">#22</span>
        Capabilities: <span class="o">[</span>1fc v1<span class="o">]</span> Vendor Specific Information: <span class="nv">ID</span><span class="o">=</span><span class="m">0002</span> <span class="nv">Rev</span><span class="o">=</span><span class="m">4</span> <span class="nv">Len</span><span class="o">=</span><span class="m">100</span> &lt;?&gt;
        Capabilities: <span class="o">[</span>2fc v1<span class="o">]</span> Vendor Specific Information: <span class="nv">ID</span><span class="o">=</span><span class="m">0001</span> <span class="nv">Rev</span><span class="o">=</span><span class="m">1</span> <span class="nv">Len</span><span class="o">=</span><span class="m">038</span> &lt;?&gt;
        Capabilities: <span class="o">[</span><span class="m">334</span> v1<span class="o">]</span> <span class="c1">#25</span>
        Kernel driver in use: dtu
        Kernel modules: enflame
</code></pre></td></tr></table>
</div>
</div><p>lspci显示存在3个bar space，物理地址分别在0xa1000000, 0xa2000000, 0x4000000000</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">Region 0: Memory at a2000000 <span class="o">(</span>32-bit, non-prefetchable<span class="o">)</span> <span class="o">[</span><span class="nv">size</span><span class="o">=</span>16K<span class="o">]</span>
Region 1: Memory at a1000000 <span class="o">(</span>32-bit, non-prefetchable<span class="o">)</span> <span class="o">[</span><span class="nv">size</span><span class="o">=</span>16M<span class="o">]</span>
Region 2: Memory at <span class="m">4000000000</span> <span class="o">(</span>64-bit, prefetchable<span class="o">)</span> <span class="o">[</span><span class="nv">size</span><span class="o">=</span>16G<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>查看/proc/iomem，存在对应物理地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">root@wang-1604:~# cat /proc/iomem <span class="p">|</span>grep 0000:01
  a1000000-a20fffff : PCI Bus 0000:01
    a1000000-a1ffffff : 0000:01:00.0
    a2000000-a2003fff : 0000:01:00.0
  4000000000-43ffffffff : PCI Bus 0000:01
    4000000000-43ffffffff : 0000:01:00.0
</code></pre></td></tr></table>
</div>
</div><h2 id="normal-memory和device-memory">normal memory和device memory</h2>
<p><strong>normal memory</strong>：normal memory就是我们平常所说的内存，对该种memory访问时无副作用(side effect)，即第n次访问与第n+1次访问没有任何差别（对比device memory的side effect特性，更容易理解一些）。</p>
<p>进一步地，通过memory attribute可以对normal memory进行细分，一段vma（virtual memory address）的memory attribute定义在页表的描述符中。</p>
<ol>
<li>
<p>是否可共享：</p>
<ul>
<li>shareable:可以被所有PE（Processing Element，处理元素）访问，包括inner shareable和outer shareable。</li>
<li>non-shareable：只能被唯一的PE访问。</li>
</ul>
</li>
<li>
<p>是否支持缓存：</p>
<ul>
<li>write-through cacheable：同时写入cache与内存，可以理解为写穿；</li>
<li>write-back cacheable：只写入cache，不更新内存，内存更新操作放到之后的适当时机；</li>
<li>non-cacheable：无cache，直接读写内存。</li>
</ul>
</li>
</ol>
<p><strong>device memory</strong>：The Device memory type attributes define memory locations where an access to the location can cause side-effects, or where the value returned for a load can vary depending on the number of loads performed. Typically, the Device memory attributes are used for memory-mapped peripherals and similar locations.</p>
<p>简言之，device memory是外设对应的物理地址空间，对该部分memory访问时，可能存在副作用（side effect），比如</p>
<ul>
<li>某些状态寄存器可能read clear；</li>
<li>某些寄存器有写入顺序（否则写入不成功）；</li>
<li>设备fifo地址固定不变，但是每次访问，内部的移位寄存器就会将下一个数据移出来[1]，因此访问同一地址第n次访问与第n+1次访问结果是不同的。</li>
</ul>
<p>进一步地，通过memory attribute可以对device memory进行细分</p>
<ol>
<li>是否可合并访问
<ul>
<li>non-Gathering（nG）：处理器必须严格按照代码中内存访问来进行，不能把多次访问合并成一次。例如，代码中有两次对同样一个地址的读访问，此时处理器必须严格进行两次read操作。</li>
<li>Gathering（G）：处理器可以对内存访问进行合并。</li>
</ul>
</li>
<li>是否可乱序
<ul>
<li>non re-ordering（nR）：处理器不允许对内存访问指令进行重排，必须严格执行program order；</li>
<li>re-ordering（R）：处理器允许对内存访问指令进行重排。</li>
</ul>
</li>
<li>写入是否可中途返回（Early Write Acknowledgement–EWA）（E or nE）</li>
</ol>
<p>PE对内存的访问是有问有答的（专业术语叫transaction），对于写入操作，PE需要收到write ack才能确定完成了一个transaction。为了加快写的速度，系统的中间环节可能会设定一些write buffer（比如cache），<strong>nE代表写操作的write ack必须来自最终目的地，而不是中间的write buffer。</strong></p>
<p><!-- raw HTML omitted --><strong>综上：设备的bar0，bar1主要是寄存器，属于device memory，bar2是hbm内存，可以认为是normal memory</strong><!-- raw HTML omitted --></p>
<h2 id="io-memory">io memory</h2>
<p>在系统运行时，外设的I/O内存资源的物理地址是已知的，这是由硬件设计决定的。但是CPU通常并没有为这些已知的外设I/O内存资源的物理地址预定义虚拟地址范围，驱动程序并不能直接通过物理地址访问I/O内存资源，而必须将它们映射到核心虚地址空间内（通过页表），然后才能根据映射所得到的核心虚地址范围，通过访内指令访问这些I/O内存资源。</p>
<p>根据计算机平台和所使用总线的不同，I/O 内存可能是，也可能不是通过页表访问的，通过页表访问的是统一编址（PowerPC），否则是独立编址(Intel)。如果访问是经由页表进行的，内核必须首先安排物理地址使其对设备驱动 程序可见（这通常意味着在进行任何 I/O 之前必须先调用 ioremap）。如果访问无需页表，那么 I/O 内存区域就很象 I/O 端口，可以使 用适当形式的函数读写它们。</p>
<p>ioremap函数组共有五个接口，根据函数实现可以分为三类:</p>
<ul>
<li>ioremap &amp; ioremap_nocache实现相同，使用场景为映射device memory类型内存；</li>
<li>ioremap_cached，使用场景为映射normal memory类型内存，且映射后的虚拟内存支持cache；</li>
<li>ioremap_wc &amp; ioremap_wt实现相同，使用场景为映射normal memory类型内训，且映射后的虚拟内存不支持cache</li>
</ul>
<p>在将I/O内存资源的物理地址映射成核心虚地址后，理论上讲我们就可以象读写RAM那样直接读写I/O内存资源了。<!-- raw HTML omitted -->**为了保证驱动程序的跨平台的可移植性，我们应该使用Linux中特定的函数来访问I/O内存资源，而不应该通过指向核心虚地址的指针来访问。**<!-- raw HTML omitted -->如在x86平台上，读写I/O的函数如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define readb(addr) (*(volatile unsigned char *) __io_virt(addr))
</span><span class="cp">#define readw(addr) (*(volatile unsigned short *) __io_virt(addr))
</span><span class="cp">#define readl(addr) (*(volatile unsigned int *) __io_virt(addr))
</span><span class="cp"></span>
<span class="cp">#define writeb(b,addr) (*(volatile unsigned char *) __io_virt(addr) = (b))
</span><span class="cp">#define writew(b,addr) (*(volatile unsigned short *) __io_virt(addr) = (b))
</span><span class="cp">#define writel(b,addr) (*(volatile unsigned int *) __io_virt(addr) = (b))
</span><span class="cp"></span>
<span class="cp">#define memset_io(a,b,c) memset(__io_virt(a),(b),(c))
</span><span class="cp">#define memcpy_fromio(a,b,c) memcpy((a),__io_virt(b),(c))
</span><span class="cp">#define memcpy_toio(a,b,c) memcpy(__io_virt(a),(b),(c))
</span></code></pre></td></tr></table>
</div>
</div><p>这些io函数在不同的平台，实现是不一样的，与内存的memcpy，memset相比，考虑了对齐，依赖io read/write函数读写数据。这也是为什么跨平台代码推荐使用io函数操作io类型内存的原因。</p>
<p>X86：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#define memcpy_fromio memcpy_fromio
#define memcpy_toio memcpy_toio
#define memset_io memset_io

void memcpy_fromio(void *to, const volatile void __iomem *from, size_t n)
{
	if (unlikely(!n))
		return;

	/* Align any unaligned source IO */
	if (unlikely(1 &amp; (unsigned long)from)) {
		movs(&#34;b&#34;, to, from);
		n--;
	}
	if (n &gt; 1 &amp;&amp; unlikely(2 &amp; (unsigned long)from)) {
		movs(&#34;w&#34;, to, from);
		n-=2;
	}
	rep_movs(to, (const void *)from, n);
}
EXPORT_SYMBOL(memcpy_fromio);

void memcpy_toio(volatile void __iomem *to, const void *from, size_t n)
{
	if (unlikely(!n))
		return;

	/* Align any unaligned destination IO */
	if (unlikely(1 &amp; (unsigned long)to)) {
		movs(&#34;b&#34;, to, from);
		n--;
	}
	if (n &gt; 1 &amp;&amp; unlikely(2 &amp; (unsigned long)to)) {
		movs(&#34;w&#34;, to, from);
		n-=2;
	}
	rep_movs((void *)to, (const void *) from, n);
}
EXPORT_SYMBOL(memcpy_toio);

void memset_io(volatile void __iomem *a, int b, size_t c)
{
	/*
	 * TODO: memset can mangle the IO patterns quite a bit.
	 * perhaps it would be better to use a dumb one:
	 */
	memset((void *)a, b, c);
}
</code></pre></td></tr></table>
</div>
</div><p>arm：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define memset_io(c,v,l)	__memset_io((c),(v),(l))
</span><span class="cp">#define memcpy_fromio(a,c,l)	__memcpy_fromio((a),(c),(l))
</span><span class="cp">#define memcpy_toio(c,a,l)	__memcpy_toio((c),(a),(l))
</span><span class="cp"></span>
<span class="cm">/*
</span><span class="cm"> * Copy data from IO memory space to &#34;real&#34; memory space.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__memcpy_fromio</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span> <span class="o">=</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
		<span class="n">from</span><span class="o">++</span><span class="p">;</span>
		<span class="n">to</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
		<span class="n">from</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">to</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span> <span class="o">=</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
		<span class="n">from</span><span class="o">++</span><span class="p">;</span>
		<span class="n">to</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__memcpy_fromio</span><span class="p">);</span>

<span class="cm">/*
</span><span class="cm"> * Copy data from &#34;real&#34; memory space to IO memory space.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__memcpy_toio</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">to</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__raw_writeb</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
		<span class="n">from</span><span class="o">++</span><span class="p">;</span>
		<span class="n">to</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
		<span class="n">from</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">to</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeb</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
		<span class="n">from</span><span class="o">++</span><span class="p">;</span>
		<span class="n">to</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__memcpy_toio</span><span class="p">);</span>

<span class="cm">/*
</span><span class="cm"> * &#34;memset&#34; on IO memory space.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__memset_io</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">qc</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">c</span><span class="p">;</span>

	<span class="n">qc</span> <span class="o">|=</span> <span class="n">qc</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">qc</span> <span class="o">|=</span> <span class="n">qc</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">qc</span> <span class="o">|=</span> <span class="n">qc</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dst</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__raw_writeb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
		<span class="n">dst</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
		<span class="n">dst</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
		<span class="n">dst</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="write-combine">write combine</h2>
<p>对于现代cpu而言，性能瓶颈则是对于内存的访问。cpu的速度往往都比主存的高至少两个数量级。因此cpu都引入了L1_cache与L2_cache,更加高端的cpu还加入了L3_cache.很显然，这个技术引起了下一个问题:</p>
<p>如果一个cpu在执行的时候需要访问的内存都不在cache中，cpu必须要通过内存总线到主存中取，那么在数据返回到cpu这段时间内（这段时间大致为cpu执行成百上千条指令的时间，至少两个数据量级）干什么呢？ 答案是cpu会继续执行其他的符合条件的指令。比如cpu有一个指令序列 指令1  指令2  指令3 …， 在指令1时需要访问主存，在数据返回前cpu会继续后续的和指令1在逻辑关系上没有依赖的”独立指令”，cpu一般是依赖指令间的内存引用关系来判断的指令间的”独立关系”，具体细节可参见各cpu的文档。这也是导致cpu乱序执行指令的根源之一。</p>
<p>以上方案是cpu对于读取数据延迟所做的性能补救的办法。对于写数据则会显得更加复杂一点：</p>
<p>当cpu执行存储指令时，它会首先试图将数据写到离cpu最近的L1_cache, 如果此时cpu出现L1未命中，则会访问下一级缓存。速度上L1_cache基本能和cpu持平，其他的均明显低于cpu，L2_cache的速度大约比cpu慢20-30倍，而且还存在L2_cache不命中的情况，又需要更多的周期去主存读取。其实在L1_cache未命中以后，cpu就会使用一个另外的缓冲区，叫做合并写存储缓冲区。这一技术称为合并写入技术。在请求L2_cache缓存行的所有权尚未完成时，cpu会把待写入的数据写入到合并写存储缓冲区，该缓冲区大小和一个cache line大小，一般都是64字节。这个缓冲区允许cpu在写入或者读取该缓冲区数据的同时继续执行其他指令，这就缓解了cpu写数据时cache miss时的性能影响。</p>
<p>当后续的写操作需要修改相同的缓存行时，这些缓冲区变得非常有趣。在将后续的写操作提交到L2缓存之前，可以进行缓冲区写合并。 这些64字节的缓冲区维护了一个64位的字段，每更新一个字节就会设置对应的位，来表示将缓冲区交换到外部缓存时哪些数据是有效的。当然，如果程序读取已被写入到该缓冲区的某些数据，那么在读取缓存数据之前会先去读取本缓冲区的。</p>
<p>经过上述步骤后，缓冲区的数据还是会在某个延时的时刻更新到外部的缓存（L2_cache）.如果我们能在缓冲区传输到缓存之前将其尽可能填满，这样的效果就会提高各级传输总线的效率，以提高程序性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">items</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arrayA</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arrayB</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arrayC</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arrayD</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arrayE</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arrayF</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arrayG</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arrayH</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">];</span>

<span class="kt">double</span> <span class="nf">run_one_case_for_8</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">start_time</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">end_time</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">end</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">iterations</span><span class="p">;</span>
    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">arrayA</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayB</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayC</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayD</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayE</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayF</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayG</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayH</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">start</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">;</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">end</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">run_two_case_for_4</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">start_time</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">end_time</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">end</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">iterations</span><span class="p">;</span>
    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">arrayA</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayB</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayC</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayD</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">iterations</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">arrayG</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayE</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayF</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">arrayH</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">start</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">;</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">end</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">items</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;test begin----&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34; %d, run_one_case_for_8: %lf</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">run_one_case_for_8</span><span class="p">());</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34; %d, run_two_case_for_4: %lf</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">run_two_case_for_4</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;test end&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>测试结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">root@wang-1604:~/Desktop# ./wc-test 
<span class="nb">test</span> begin----&gt;
 0, run_one_case_for_8: 27.442992
 0, run_two_case_for_4: 12.841221
 1, run_one_case_for_8: 27.068290
 1, run_two_case_for_4: 12.692629
 2, run_one_case_for_8: 27.159333
 2, run_two_case_for_4: 12.675539
</code></pre></td></tr></table>
</div>
</div><p>原理:上面提到的合并写存入缓冲区离cpu很近，容量为64字节，很小了，估计很贵。数量也是有限的，我这款cpu它的个数为4。个数时依赖cpu模型的，intel的cpu在同一时刻只能拿到4个。</p>
<p>因此，run_one_case_for_8函数中连续写入8个不同位置的内存，那么当4个数据写满了合并写缓冲时，cpu就要等待合并写缓冲区更新到L2cache中，因此cpu就被强制暂停了。然而在run_two_case_for_4函数中是每次写入4个不同位置的内存，可以很好的利用合并写缓冲区，因合并写缓冲区满到引起的cpu暂停的次数会大大减少，当然如果每次写入的内存位置数目小于4，也是一样的。虽然多了一次循环的i++操作（实际上你可能会问，i++也是会写入内存的啊，其实i这个变量保存在了寄存器上）， 但是它们之间的性能差距依然非常大。</p>
<p><!-- raw HTML omitted -->**开启write combine以后，相当于写地址都是对齐的，所以在arm上即使不用io专用函数，依然可以正常运行memset。**<!-- raw HTML omitted --></p>
<h2 id="arm-memset问题">ARM memset问题</h2>
<p><!-- raw HTML omitted -->arm对于对齐data的读写明显快于不对齐的，所以它的memset实现，无论kernel还是umd，都是考虑对齐优化的<!-- raw HTML omitted --></p>
<p>首先看kernel mode，kernel里面对io内存的memset，如果不使用io专用函数操作，memset直接访问必定因为对齐因素出现crash。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>  196.090332<span class="o">]</span> Unable to handle kernel paging request at virtual address ffff00001fb20000
<span class="o">[</span>  196.090377<span class="o">]</span> Mem abort info:
<span class="o">[</span>  196.090393<span class="o">]</span>   <span class="nv">ESR</span> <span class="o">=</span> 0x96000061
<span class="o">[</span>  196.090412<span class="o">]</span>   Exception <span class="nv">class</span> <span class="o">=</span> DABT <span class="o">(</span>current EL<span class="o">)</span>, <span class="nv">IL</span> <span class="o">=</span> <span class="m">32</span> bits
<span class="o">[</span>  196.090440<span class="o">]</span>   <span class="nv">SET</span> <span class="o">=</span> 0, <span class="nv">FnV</span> <span class="o">=</span> 0
<span class="o">[</span>  196.090457<span class="o">]</span>   <span class="nv">EA</span> <span class="o">=</span> 0, <span class="nv">S1PTW</span> <span class="o">=</span> 0
<span class="o">[</span>  196.090474<span class="o">]</span> Data abort info:
<span class="o">[</span>  196.090490<span class="o">]</span>   <span class="nv">ISV</span> <span class="o">=</span> 0, <span class="nv">ISS</span> <span class="o">=</span> 0x00000061
<span class="o">[</span>  196.090509<span class="o">]</span>   <span class="nv">CM</span> <span class="o">=</span> 0, <span class="nv">WnR</span> <span class="o">=</span> 1
<span class="o">[</span>  196.090527<span class="o">]</span> swapper pgtable: 64k pages, 48-bit VAs, <span class="nv">pgdp</span> <span class="o">=</span> 00000000fae502d6
<span class="o">[</span>  196.090560<span class="o">]</span> <span class="o">[</span>ffff00001fb20000<span class="o">]</span> <span class="nv">pgd</span><span class="o">=</span>00000381fffe0803, <span class="nv">pud</span><span class="o">=</span>00000381fffe0803, <span class="nv">pmd</span><span class="o">=</span>00000381fffd0803, <span class="nv">pte</span><span class="o">=</span>0068082000610f07
<span class="o">[</span>  196.090610<span class="o">]</span> Internal error: Oops: <span class="m">96000061</span> <span class="o">[</span><span class="c1">#1] SMP</span>
<span class="o">[</span>  196.090633<span class="o">]</span> Modules linked in: dtu<span class="o">(</span>OE+<span class="o">)</span> dtu_kcl<span class="o">(</span>OE<span class="o">)</span> mpt3sas ast igb ttm raid_class rtc_ds1307
<span class="o">[</span>  196.090677<span class="o">]</span> Process kworker/0:3 <span class="o">(</span>pid: 737, stack <span class="nv">limit</span> <span class="o">=</span> 0x0000000031d7cfb7<span class="o">)</span>
<span class="o">[</span>  196.090712<span class="o">]</span> CPU: <span class="m">0</span> PID: <span class="m">737</span> Comm: kworker/0:3 Kdump: loaded Tainted: G           OE     4.19.90-17.ky10.aarch64 <span class="c1">#1</span>
<span class="o">[</span>  196.090756<span class="o">]</span> Hardware name:  /, BIOS RELEASE 5.6 Aug <span class="m">17</span> 2020
<span class="o">[</span>  196.090789<span class="o">]</span> Workqueue: events work_for_cpu_fn
<span class="o">[</span>  196.090811<span class="o">]</span> pstate: <span class="m">40000005</span> <span class="o">(</span>nZcv daif -PAN -UAO<span class="o">)</span>
<span class="o">[</span>  196.090837<span class="o">]</span> pc : __memset+0x16c/0x188
<span class="o">[</span>  196.090904<span class="o">]</span> lr : dtu_bp_create+0x84/0xc0 <span class="o">[</span>dtu<span class="o">]</span>
<span class="o">[</span>  196.091530<span class="o">]</span> sp : ffff80814d7ffab0
<span class="o">[</span>  196.092128<span class="o">]</span> x29: ffff80814d7ffab0 x28: <span class="m">0000000000000000</span> 
<span class="o">[</span>  196.092723<span class="o">]</span> x27: <span class="m">0000000000000000</span> x26: ffff0000024b0000 
<span class="o">[</span>  196.093301<span class="o">]</span> x25: <span class="m">0000000000000000</span> x24: <span class="m">0000000000000002</span> 
<span class="o">[</span>  196.093859<span class="o">]</span> x23: ffff0000024689c0 x22: ffff808107001680 
<span class="o">[</span>  196.094403<span class="o">]</span> x21: <span class="m">0000000000000001</span> x20: <span class="m">0000000000000000</span> 
<span class="o">[</span>  196.094948<span class="o">]</span> x19: ffff83810d6bb000 x18: <span class="m">0000000000000020</span> 
<span class="o">[</span>  196.095494<span class="o">]</span> x17: ffff808107000110 x16: ffff808107000110 
<span class="o">[</span>  196.096032<span class="o">]</span> x15: ffff0000091de000 x14: 5f766564202c3239 
<span class="o">[</span>  196.096566<span class="o">]</span> x13: 3138203a657a6973 x12: 202c6f62206c656e 
<span class="o">[</span>  196.097110<span class="o">]</span> x11: <span class="m">0000000000000000</span> x10: <span class="m">0000000000000004</span> 
<span class="o">[</span>  196.097656<span class="o">]</span> x9 : <span class="m">0000000000000000</span> x8 : ffff00001fb20000 
<span class="o">[</span>  196.098204<span class="o">]</span> x7 : <span class="m">0000000000000000</span> x6 : 000000000000003f 
<span class="o">[</span>  196.098746<span class="o">]</span> x5 : <span class="m">0000000000000040</span> x4 : <span class="m">0000000000000000</span> 
<span class="o">[</span>  196.099271<span class="o">]</span> x3 : <span class="m">0000000000000004</span> x2 : 0000000000001fc0 
<span class="o">[</span>  196.099777<span class="o">]</span> x1 : <span class="m">0000000000000000</span> x0 : ffff00001fb20000 
<span class="o">[</span>  196.100268<span class="o">]</span> Call trace:
<span class="o">[</span>  196.100742<span class="o">]</span>  __memset+0x16c/0x188
<span class="o">[</span>  196.101270<span class="o">]</span>  dtu_bp_init+0x68/0x1c0 <span class="o">[</span>dtu<span class="o">]</span>
<span class="o">[</span>  196.101790<span class="o">]</span>  leo_ih_init+0x5c/0x68 <span class="o">[</span>dtu<span class="o">]</span>
<span class="o">[</span>  196.102291<span class="o">]</span>  dtu_ip_instance_init+0x14c/0x298 <span class="o">[</span>dtu<span class="o">]</span>
<span class="o">[</span>  196.102787<span class="o">]</span>  dtu_device_ips_init+0x174/0x648 <span class="o">[</span>dtu<span class="o">]</span>
<span class="o">[</span>  196.103266<span class="o">]</span>  dtu_device_init.part.3+0x51c/0xd68 <span class="o">[</span>dtu<span class="o">]</span>
<span class="o">[</span>  196.103727<span class="o">]</span>  dtu_device_init+0x48/0xa0 <span class="o">[</span>dtu<span class="o">]</span>
<span class="o">[</span>  196.104167<span class="o">]</span>  dtu_pci_probe+0x22c/0x8f0 <span class="o">[</span>dtu<span class="o">]</span>
<span class="o">[</span>  196.104536<span class="o">]</span>  local_pci_probe+0x3c/0xb8
<span class="o">[</span>  196.104898<span class="o">]</span>  work_for_cpu_fn+0x18/0x28
<span class="o">[</span>  196.105254<span class="o">]</span>  process_one_work+0x1f0/0x3c8
<span class="o">[</span>  196.105607<span class="o">]</span>  worker_thread+0x26c/0x4d0
<span class="o">[</span>  196.105961<span class="o">]</span>  kthread+0x128/0x130
<span class="o">[</span>  196.106308<span class="o">]</span>  ret_from_fork+0x10/0x18
<span class="o">[</span>  196.106652<span class="o">]</span> Code: <span class="m">91010108</span> 54ffff4a 8b040108 cb050042 <span class="o">(</span>d50b7428<span class="o">)</span> 
<span class="o">[</span>  196.107045<span class="o">]</span> SMP: stopping secondary CPUs
<span class="o">[</span>  196.107898<span class="o">]</span> Starting crashdump kernel...
<span class="o">[</span>  196.108259<span class="o">]</span> Bye!
</code></pre></td></tr></table>
</div>
</div><p>对umd，mmap出来的虚地址指针（ioremap方式映射），直接memset访问的话，由于汇编指令里面用到了DC ZVA指令，遇到device memory就会报对齐错误，这也是为什么会出现sigbus错误的原因。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">If the memory region being zeroed is any type of Device memory, these
instructions give an alignment fault which is prioritized in the same way
as other alignment faults that are determined by the memory type.&#34;
from arm reference menual
</code></pre></td></tr></table>
</div>
</div><p>解决办法是设置缺页属性为pgprot_writecombine。详见https://qiita.com/ikwzm/items/3216f907ff8fc41866c4</p>
<p>arm memset分析：https://www.reexpound.com/2021/05/26/arm性能优化三-memset-优化/</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/* Copyright (C) 2012-2019 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   &lt;http://www.gnu.org/licenses/&gt;.  */
#include &lt;sysdep.h&gt;
#include &#34;memset-reg.h&#34;
#ifndef MEMSET
# define MEMSET memset
#endif

/* Assumptions:
 *
 * ARMv8-a, AArch64, unaligned accesses
 *
 */
ENTRY_ALIGN (MEMSET, 6)
        DELOUSE (0)
        DELOUSE (2)
        dup        v0.16B, valw
        add        dstend, dstin, count
        cmp        count, 96
        b.hi        L(set_long)
        cmp        count, 16
        b.hs        L(set_medium)
        mov        val, v0.D[0]
        /* Set 0..15 bytes.  */
        tbz        count, 3, 1f
        str        val, [dstin]
        str        val, [dstend, -8]
        ret
        nop
1:      tbz        count, 2, 2f
        str        valw, [dstin]
        str        valw, [dstend, -4]
        ret
2:     cbz        count, 3f
        strb        valw, [dstin]
        tbz        count, 1, 3f
        strh        valw, [dstend, -2]
3:      ret
        /* Set 17..96 bytes.  */
L(set_medium):
        str        q0, [dstin]
        tbnz        count, 6, L(set96)
        str        q0, [dstend, -16]
        tbz        count, 5, 1f
        str        q0, [dstin, 16]
        str        q0, [dstend, -32]
1:      ret

        .p2align 4
        /* Set 64..96 bytes.  Write 64 bytes from the start and
           32 bytes from the end.  */
L(set96):
        str        q0, [dstin, 16]
        stp        q0, q0, [dstin, 32]
        stp        q0, q0, [dstend, -32]
        ret
        .p2align 3
        nop
L(set_long):
        and        valw, valw, 255
        bic        dst, dstin, 15
        str        q0, [dstin]
        cmp        count, 256
        ccmp        valw, 0, 0, cs
        b.eq        L(try_zva)
L(no_zva):
        sub        count, dstend, dst        /* Count is 16 too large.  */
        sub        dst, dst, 16                /* Dst is biased by -32.  */
        sub        count, count, 64 + 16        /* Adjust count and bias for loop.  */
1:      stp        q0, q0, [dst, 32]
        stp        q0, q0, [dst, 64]!
L(tail64):
        subs        count, count, 64
        b.hi        1b
2:      stp        q0, q0, [dstend, -64]
        stp        q0, q0, [dstend, -32]
        ret

L(try_zva):
#ifdef ZVA_MACRO
        zva_macro
#else
        .p2align 3
        mrs        tmp1, dczid_el0
        tbnz        tmp1w, 4, L(no_zva)
        and        tmp1w, tmp1w, 15
        cmp        tmp1w, 4        /* ZVA size is 64 bytes.  */
        b.ne         L(zva_128)
        /* Write the first and last 64 byte aligned block using stp rather
           than using DC ZVA.  This is faster on some cores.
         */
L(zva_64):
        str        q0, [dst, 16]
        stp        q0, q0, [dst, 32]
        bic        dst, dst, 63
        stp        q0, q0, [dst, 64]
        stp        q0, q0, [dst, 96]
        sub        count, dstend, dst        /* Count is now 128 too large.        */
        sub        count, count, 128+64+64        /* Adjust count and bias for loop.  */
        add        dst, dst, 128
        nop
1:      dc         zva, dst
        add        dst, dst, 64
        subs       count, count, 64
        b.hi        1b
        stp        q0, q0, [dst, 0]
        stp        q0, q0, [dst, 32]
        stp        q0, q0, [dstend, -64]
        stp        q0, q0, [dstend, -32]
        ret

        .p2align 3
L(zva_128):
        cmp        tmp1w, 5        /* ZVA size is 128 bytes.  */
        b.ne        L(zva_other)
        str        q0, [dst, 16]
        stp        q0, q0, [dst, 32]
        stp        q0, q0, [dst, 64]
        stp        q0, q0, [dst, 96]
        bic        dst, dst, 127
        sub        count, dstend, dst        /* Count is now 128 too large.        */
        sub        count, count, 128+128        /* Adjust count and bias for loop.  */
        add        dst, dst, 128
1:      dc        zva, dst
        add        dst, dst, 128
        subs        count, count, 128
        b.hi        1b
        stp        q0, q0, [dstend, -128]
        stp        q0, q0, [dstend, -96]
        stp        q0, q0, [dstend, -64]
        stp        q0, q0, [dstend, -32]
        ret

L(zva_other):
        mov        tmp2w, 4
        lsl        zva_lenw, tmp2w, tmp1w
        add        tmp1, zva_len, 64        /* Max alignment bytes written.         */
        cmp        count, tmp1
        blo        L(no_zva)
        sub        tmp2, zva_len, 1
        add        tmp1, dst, zva_len
        add        dst, dst, 16
        subs        count, tmp1, dst        /* Actual alignment bytes to write.  */
        bic        tmp1, tmp1, tmp2        /* Aligned dc zva start address.  */
        beq        2f
1:      stp        q0, q0, [dst], 64
        stp        q0, q0, [dst, -32]
        subs        count, count, 64
        b.hi        1b
2:      mov        dst, tmp1
        sub        count, dstend, tmp1        /* Remaining bytes to write.  */
        subs        count, count, zva_len
        b.lo        4f
3:      dc        zva, dst
        add        dst, dst, zva_len
        subs        count, count, zva_len
        b.hs        3b
4:      add        count, count, zva_len
        sub        dst, dst, 32                /* Bias dst for tail loop.  */
        b        L(tail64)
#endif
END (MEMSET)
libc_hidden_builtin_def (MEMSET)
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">carter2005</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-09-20
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2021/2021-09-22_lubuntu_2004_home_server/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">lubuntu 20.04 home_server</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/2021/2021-06-24_watchdog_soft_lockup/">
            <span class="next-text nav-default">watchdog: BUG: soft lockup - CPU#0 stuck for 22s</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="carter2005/carter2005.github.io"
            issue-term="title"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:carter2008@gmail.com" class="iconfont icon-email" title="email"></a>
  <a href="https://carter2005.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2025
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">carter2005</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://fastly.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://fastly.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-7CB6WNEBLM', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
